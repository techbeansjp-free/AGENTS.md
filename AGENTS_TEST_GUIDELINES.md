# AGENTS_TEST_GUIDELINES - テスト作成ガイドライン

> このファイルは、AI エージェントがテストを作成・レビューする際に遵守すべき「テスト技法」「観点」「レベル」を整理したガイドラインです。  
> **AI エージェント向け**: このガイドラインは [`AGENTS_AI_PLAYBOOK.md`](./AGENTS_AI_PLAYBOOK.md) の実装フェーズから参照されます。  
> 詳細な思想・背景は [`AGENTS.md`](./AGENTS.md) を参照し、ここでは **テストに特化した実践的な指針** を定義します。

---

## クイックリファレンス

### テスト作成の基本方針

1. **仕様ベース（BDD）で書く**: 受け入れ条件を Given-When-Then で表現
2. **リスクベースで優先度を決める**: クリティカルな機能は厚くテスト
3. **テストピラミッドを意識**: 単体テスト多め、結合/API テストそこそこ、E2E 少なめ
4. **運用保守に耐えうるテスト**: 実装の詳細に依存せず、値の変更に強いテスト設計
5. **正常系は動いて当たり前**: 異常系・境界値に重点を置く。正常系は最小限で OK
6. **バリデーションは網羅的に**: バリデーション系のテストは漏れなく実施
7. **エラーレスポンス形式の検証は必須**: すべてのエラーレスポンス（400, 401, 403, 404, 422, 500等）の形式を検証
8. **ブラックボックステストを優先**: APIの入力と出力のみを検証し、内部実装に依存しない
9. **ホワイトボックステストで補完**: エラーハンドラーや例外処理の内部実装を検証
10. **E2Eテストでは`data-testid`を使用**: UIの変更に影響されにくい、安定したテストを書く

### テスト観点のチェックリスト

- **入力・データ**: 正常系、境界値、異常系、組み合わせ、ロケール/文字種
- **状態・フロー**: 状態遷移、画面/ステップフロー、中断・キャンセル
- **時間・並行・順序**: 日付境界、並行実行、順序依存
- **エラー/障害系**: 外部 API、DB、ネットワーク、エラーハンドリング
- **非機能**: パフォーマンス、セキュリティ、ログ・監視

### レベル別の意識

- **単体テスト**: 多方向で攻める（値のバリエーション、条件分岐の全パス、状態変化前後）
- **結合/API テスト**: コンポーネント間の契約チェック、代表的なフロー
- **E2E/受け入れテスト**: BDD の Feature/Scenario をそのままテストに
- **回帰テスト**: バグ修正時に必ずテストを追加

---

## 目次

- [全体方針](#全体方針)
- [正常系と異常系のテスト配分](#正常系と異常系のテスト配分)
- [バリデーション系のテスト](#バリデーション系のテスト)
- [エラーレスポンス形式の検証](#エラーレスポンス形式の検証)
- [ブラックボックステストとホワイトボックステスト](#ブラックボックステストとホワイトボックステスト)
- [運用保守に耐えうるテスト設計](#運用保守に耐えうるテスト設計)
- [フロントエンド向けのテストガイドライン](#フロントエンド向けのテストガイドライン)
- [観点のチェックリスト](#観点のチェックリスト)
- [レベル別の意識](#レベル別の意識)
- [BDD 前提でのテストの作り方](#bdd前提でのテストの作り方)
- [テスト作成時の小さな指針](#テスト作成時の小さな指針)
- [参考資料](#参考資料)

---

## 全体方針

### 1. 仕様ベース（BDD）で書く

- **仕様 = 受け入れ条件（AC）を Given-When-Then で書く**
- **テストケースは「仕様の例（Example）」として扱う**
- 実装の詳細ではなく、**振る舞い（動作・機能）** を中心に考える

### 2. リスクベースで優先度を決める

- **クリティカルな機能**（課金、締め処理、削除系）は正常系も異常系もテストを厚く
- **影響範囲が広いところ**は回帰テストに必ず入れる
- **頻繁に変更される箇所**はテストを充実させる

### 3. テストピラミッドを意識

```
        E2E/シナリオ
      （少ないが重要なハッピーパス＋主要バッドパス）

    ────────────────────────

    結合/APIテスト
    （そこそこ）

    ────────────────────────

    単体テスト
    （多い：高速・細かい）
```

- **単体テスト**: 多い（高速・細かい）
- **結合/API テスト**: そこそこ
- **E2E/シナリオ**: 少ないが重要なハッピーパス＋主要バッドパス

### 4. 運用保守に耐えうるテスト設計

- **実装の詳細に依存しない**: 内部実装が変わってもテストが落ちない
- **値の変更に強い**: ロジック的に正しいのに値を変えたら動かなくなるようなテストは NG
- **テストの安定性**: フレーキーテスト（不安定なテスト）を避ける
- **テストの保守性**: テストコード自体が保守しやすい

### 5. 正常系と異常系のテスト配分

**重要**: **正常系は動いて当たり前**です。テストの重点は**異常系・境界値**に置くべきです。

- **正常系**: 最小限で OK（代表的なケース 1〜2 個程度）
- **異常系**: 網羅的にテスト（すべてのエラーケースをカバー）
- **境界値**: 重点的にテスト（最小値、最大値、0、NULL 等）

---

## 正常系と異常系のテスト配分

### 基本方針

**正常系は動いて当たり前**です。テストの重点は**異常系・境界値**に置くべきです。

### 正常系のテスト

- [ ] **最小限で OK**
  - 代表的なケース 1〜2 個程度で十分
  - ハッピーパスが動作することを確認する程度
- [ ] **過剰な正常系テストは避ける**
  - 正常系のバリエーションをすべてテストする必要はない
  - 実装が正しければ正常系は動くはず

### 異常系のテスト

- [ ] **網羅的にテスト**
  - すべてのエラーケースをカバー
  - エラーメッセージの確認も含める
- [ ] **境界値も重点的に**
  - 最小値、最大値、0、NULL 等の境界での動作
  - 境界値付近での動作も確認

### テスト配分の例

```typescript
// ✅ OK: 正常系は最小限
test("有効なメールアドレスでユーザーが登録できる", () => {
  // 代表的なケース1つだけ
  const result = registerUser({ email: "test@example.com" });
  expect(result.success).toBe(true);
});

// ✅ OK: 異常系は網羅的に
test("無効なメールアドレスでユーザー登録が失敗する", () => {
  const invalidEmails = [
    "invalid",
    "@example.com",
    "test@",
    "test@example",
    "test @example.com",
    "",
  ];
  invalidEmails.forEach((email) => {
    const result = registerUser({ email });
    expect(result.success).toBe(false);
    expect(result.error).toContain("メールアドレス");
  });
});

// ✅ OK: 境界値も重点的に
test("メールアドレスの長さ制限を超えるとエラーになる", () => {
  const longEmail = "a".repeat(250) + "@example.com";
  const result = registerUser({ email: longEmail });
  expect(result.success).toBe(false);
});
```

---

## バリデーション系のテスト

**重要**: バリデーション系のテストは**網羅的に行うべき**です。また、バリデーション自体は**サービス層で共通化**し、フォームによってバリデーションが変わらないように管理すべきです。

### 1. バリデーション系のテストは網羅的に

- [ ] **すべてのバリデーションルールをテスト**
  - 必須チェック
  - 型チェック（文字列、数値、日付等）
  - フォーマットチェック（メールアドレス、電話番号等）
  - 長さチェック（最小長、最大長）
  - 範囲チェック（最小値、最大値）
  - カスタムルール（ビジネスルールに基づく検証）
- [ ] **境界値も重点的に**
  - 最小値、最大値、0、NULL、空文字列等
  - 境界値付近での動作も確認
- [ ] **エラーメッセージも確認**
  - 適切なエラーメッセージが返されるか
  - ユーザーにとって理解しやすいメッセージか

### 2. バリデーションの共通化・サービス層での管理

#### 実装方針

- [ ] **バリデーションはサービス層で共通化**
  - フォームごとにバリデーションを実装しない
  - 共通のバリデーションサービス/ユーティリティを作成
  - 再利用可能なバリデーション関数を提供
- [ ] **フォームによってバリデーションが変わらない**
  - 同じフィールド（例：メールアドレス）は同じバリデーションルールを適用
  - バリデーションルールの一元管理
- [ ] **バリデーションルールの一元管理**
  - バリデーションルールを設定ファイルや定数として管理
  - ルールの変更が一箇所で完結する

#### 推奨実装パターン

```typescript
// ✅ OK: サービス層で共通化されたバリデーション
// services/validation/emailValidator.ts
export class EmailValidator {
  static validate(email: string): ValidationResult {
    if (!email) {
      return { valid: false, error: "メールアドレスは必須です" };
    }
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return { valid: false, error: "有効なメールアドレスを入力してください" };
    }
    if (email.length > 255) {
      return {
        valid: false,
        error: "メールアドレスは255文字以内で入力してください",
      };
    }
    return { valid: true };
  }
}

// ✅ OK: フォームで共通のバリデーションを使用
// components/forms/UserForm.tsx
const validateEmail = (email: string) => {
  return EmailValidator.validate(email);
};
```

#### テストの例

```typescript
// ✅ OK: バリデーションのテストは網羅的に
describe("EmailValidator", () => {
  // 正常系は最小限
  test("有効なメールアドレスでバリデーションが成功する", () => {
    const result = EmailValidator.validate("test@example.com");
    expect(result.valid).toBe(true);
  });

  // 異常系は網羅的に
  test("無効なメールアドレスでバリデーションが失敗する", () => {
    const invalidEmails = [
      { email: "", expected: "メールアドレスは必須です" },
      { email: "invalid", expected: "有効なメールアドレスを入力してください" },
      {
        email: "@example.com",
        expected: "有効なメールアドレスを入力してください",
      },
      { email: "test@", expected: "有効なメールアドレスを入力してください" },
      {
        email: "test@example",
        expected: "有効なメールアドレスを入力してください",
      },
      {
        email: "test @example.com",
        expected: "有効なメールアドレスを入力してください",
      },
    ];
    invalidEmails.forEach(({ email, expected }) => {
      const result = EmailValidator.validate(email);
      expect(result.valid).toBe(false);
      expect(result.error).toBe(expected);
    });
  });

  // 境界値も重点的に
  test("メールアドレスの長さ制限を超えるとエラーになる", () => {
    const longEmail = "a".repeat(250) + "@example.com";
    const result = EmailValidator.validate(longEmail);
    expect(result.valid).toBe(false);
    expect(result.error).toContain("255文字以内");
  });

  test("メールアドレスが255文字ちょうどなら成功する", () => {
    const email = "a".repeat(240) + "@example.com"; // 255文字
    const result = EmailValidator.validate(email);
    expect(result.valid).toBe(true);
  });
});
```

### 3. バリデーションのテスト観点チェックリスト

- [ ] **必須チェック**
  - 空文字列、NULL、undefined
- [ ] **型チェック**
  - 文字列、数値、日付、ブール値等
- [ ] **フォーマットチェック**
  - メールアドレス、電話番号、郵便番号、URL 等
- [ ] **長さチェック**
  - 最小長、最大長、境界値
- [ ] **範囲チェック**
  - 最小値、最大値、境界値
- [ ] **カスタムルール**
  - ビジネスルールに基づく検証
  - 複数フィールド間の関連チェック
- [ ] **エラーメッセージ**
  - 適切なメッセージが返されるか
  - ユーザーにとって理解しやすいか

---

## エラーレスポンス形式の検証

**重要**: **すべてのエラーレスポンスの形式を検証することは必須**です。エラーレスポンス形式が期待通りでない場合、フロントエンドで適切に処理できず、ユーザーに不適切なエラーメッセージが表示される可能性があります。

### 1. エラーレスポンス形式の検証は必須

- [ ] **すべてのエラーレスポンス（400, 401, 403, 404, 422, 500等）の形式を検証**
  - HTTPステータスコードが正しいか
  - レスポンスボディの形式が期待通りか（`{"detail": "..."}`形式など、プロジェクトで定義された形式）
  - エラーメッセージが適切か（ローカライズされているか、ユーザーにとって理解しやすいか）
  - 期待しないフィールドが含まれていないか
- [ ] **422エラー（バリデーションエラー）の詳細形式を検証**
  - `detail`配列の構造が正しいか
  - 各エラー要素に必要なフィールド（`type`, `loc`, `msg`, `input`等）が含まれているか
  - 複数のバリデーションエラーがすべて含まれているか
- [ ] **正常系レスポンスの形式も検証**
  - 正常系レスポンスの形式が期待通りか
  - 必須フィールドが含まれているか
  - 型が正しいか

### 2. エラーレスポンス形式の検証テストの例

```python
# ✅ OK: エラーレスポンス形式を検証するブラックボックステスト
def test_401_error_response_format(client):
    """401エラーのレスポンス形式を検証（ブラックボックステスト）."""
    # Given: 認証されていないユーザーが保護されたエンドポイントにアクセスする
    # When: 401エラーが発生する
    response = client.get("/api/v1/protected")

    # Then: エラーレスポンスが期待通りの形式である
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert response.headers["content-type"] == "application/json"

    # レスポンスボディの形式を検証
    data = response.json()
    assert "detail" in data
    assert isinstance(data["detail"], str)
    assert len(data["detail"]) > 0

    # 期待しないフィールドが含まれていないことを確認
    assert "error" not in data
    assert "code" not in data
    assert "message" not in data


# ✅ OK: 422エラーの詳細形式を検証
def test_422_error_response_format(client):
    """422エラーのレスポンス形式を検証（ブラックボックステスト）."""
    # Given: 不正なリクエストボディでAPIにアクセスする
    # When: 422エラーが発生する
    response = client.post(
        "/api/v1/users",
        json={"email": ""},  # 必須フィールドが不足
    )

    # Then: エラーレスポンスが期待通りの形式である（detail配列）
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert response.headers["content-type"] == "application/json"

    # レスポンスボディの形式を検証
    data = response.json()
    assert "detail" in data
    assert isinstance(data["detail"], list)
    assert len(data["detail"]) > 0

    # detail配列の各要素の形式を検証
    for error_detail in data["detail"]:
        assert "type" in error_detail
        assert "loc" in error_detail
        assert "msg" in error_detail
        assert isinstance(error_detail["type"], str)
        assert isinstance(error_detail["loc"], list)
        assert isinstance(error_detail["msg"], str)
```

### 3. エラーレスポンス形式の検証チェックリスト

- [ ] **HTTPステータスコード**
  - 期待されるステータスコードが返されるか
- [ ] **Content-Typeヘッダー**
  - `application/json`が設定されているか（またはプロジェクトで定義された形式）
- [ ] **レスポンスボディの構造**
  - 期待されるフィールド（`detail`等）が含まれているか
  - 期待しないフィールドが含まれていないか
  - フィールドの型が正しいか（文字列、配列等）
- [ ] **エラーメッセージの内容**
  - ローカライズされているか（該当する場合）
  - ユーザーにとって理解しやすいメッセージか
  - 適切なエラーメッセージが返されるか
- [ ] **422エラーの詳細形式（該当する場合）**
  - `detail`配列の構造が正しいか
  - 各エラー要素に必要なフィールドが含まれているか
  - 複数のバリデーションエラーがすべて含まれているか

---

## ブラックボックステストとホワイトボックステスト

**重要**: **ブラックボックステストを優先し、ホワイトボックステストで補完**します。ブラックボックステストは実装の詳細に依存しないため、実装変更に強いテストになります。ホワイトボックステストは、エラーハンドラーや例外処理の内部実装を検証するために使用します。

### 1. ブラックボックステスト（優先）

**定義**: 内部実装を知らずに、**入力と出力のみを検証**するテスト。

#### 原則

- [ ] **内部実装に依存しない**
  - データベースセッション、内部変数、プライベートメソッドに依存しない
  - APIの公開インターフェース（エンドポイント、リクエスト/レスポンス）のみを使用
- [ ] **入力と出力の関係を検証**
  - リクエストの内容とレスポンスの内容の関係を検証
  - ステータスコード、レスポンスボディの形式、エラーメッセージを検証
- [ ] **実装が変わっても同じ振る舞いならテストは通る**
  - 内部実装の変更に影響されない
  - 同じ仕様（振る舞い）を満たしていればテストは通る

#### ブラックボックステストの例

```python
# ✅ OK: ブラックボックステスト（内部実装に依存しない）
def test_login_success(client, db_session: Session):
    """ログイン成功のテスト（ブラックボックステスト）."""
    # Given: テストユーザーを作成（内部実装の詳細は知らない）
    user = User(
        username="test_user",
        email="test@example.com",
        hashed_password=get_password_hash("password"),
        is_active=True,
    )
    db_session.add(user)
    db_session.commit()

    # When: ログインAPIにリクエストを送信（入力）
    response = client.post(
        "/api/v1/auth/login",
        json={"username": "test_user", "password": "password"},
    )

    # Then: 期待されるレスポンスが返される（出力）
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == {"message": "ログインに成功しました"}
    assert "access_token" in response.cookies
    assert "refresh_token" in response.cookies
```

### 2. ホワイトボックステスト（補完）

**定義**: 内部実装を理解した上で、**内部実装の動作を検証**するテスト。

#### 使用場面

- [ ] **エラーハンドラーの内部実装を検証**
  - 例外ハンドラーが正しく動作するか
  - エラーメッセージの変換が正しく行われるか
  - ログの記録が正しく行われるか
- [ ] **例外処理の内部実装を検証**
  - 例外が正しくキャッチされるか
  - 例外の種類に応じた処理が正しく行われるか
- [ ] **カバレッジの抜け漏れ確認**
  - すべての分岐がテストされているか
  - エラーケースが網羅されているか

#### ホワイトボックステストの例

```python
# ✅ OK: ホワイトボックステスト（エラーハンドラーの内部実装を検証）
@pytest.mark.asyncio
async def test_http_exception_handler_401_unauthorized():
    """HTTPException（401エラー）のローカライズを検証（ホワイトボックステスト）."""
    # Given: HTTPException（401エラー）が発生する
    exc = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Unauthorized",
    )
    request = MagicMock(spec=Request)

    # When: http_exception_handlerが呼び出される（内部実装を直接呼び出し）
    response = await http_exception_handler(request, exc)

    # Then: ローカライズされたエラーメッセージが返される（内部実装の動作を検証）
    assert isinstance(response, JSONResponse)
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    body = json.loads(response.body.decode())
    assert "detail" in body
    assert "認証されていません" in body["detail"]
```

### 3. ブラックボックスとホワイトボックスの使い分け

#### ブラックボックステストを優先する場面

- [ ] **APIエンドポイントのテスト**
  - リクエストとレスポンスの関係を検証
  - エラーレスポンス形式の検証
- [ ] **ビジネスロジックのテスト**
  - 入力と出力の関係を検証
  - 振る舞い（仕様）を検証
- [ ] **統合テスト**
  - コンポーネント間の契約を検証
  - 代表的なフローを検証

#### ホワイトボックステストで補完する場面

- [ ] **エラーハンドラーのテスト**
  - 例外ハンドラーの内部実装を検証
  - エラーメッセージの変換ロジックを検証
- [ ] **例外処理のテスト**
  - 例外の種類に応じた処理を検証
  - ログの記録を検証
- [ ] **カバレッジの抜け漏れ確認**
  - すべての分岐がテストされているか確認

### 4. テスト設計の原則

- [ ] **ブラックボックステストを優先**
  - 実装の詳細に依存しない
  - 実装が変わっても同じ振る舞いならテストは通る
- [ ] **ホワイトボックステストで補完**
  - エラーハンドラーや例外処理の内部実装を検証
  - カバレッジの抜け漏れ確認
- [ ] **両方を組み合わせる**
  - ブラックボックステストで振る舞いを検証
  - ホワイトボックステストで内部実装を検証

---

## 運用保守に耐えうるテスト設計

**重要**: ロジック的に正しいのに値を変えたら動かなくなるようなテストは**絶対に NG**です。テストは実装の詳細ではなく、**振る舞い（仕様）** を検証するものであるべきです。

### 1. 実装の詳細に依存しないテスト設計

#### 禁止事項

- [ ] **内部実装の詳細を直接テストしない**
  - 例：`private`メソッドを直接呼び出す
  - 例：内部変数の値を直接アサートする
- [ ] **実装の変更でテストが壊れる設計**
  - 例：特定のアルゴリズムの実装に依存する
  - 例：特定のデータ構造に依存する

#### 推奨事項

- [ ] **公開インターフェース（API）を通じてテストする**
  - 入力と出力の関係を検証する
  - 副作用（状態変化、外部呼び出し等）を検証する
- [ ] **振る舞い（仕様）を検証する**
  - 「何ができるか」をテストする
  - 「どう実装されているか」はテストしない
- [ ] **ブラックボックステストを優先**
  - 内部実装を知らずに入力と出力を確認
  - 実装が変わっても同じ振る舞いならテストは通る

### 2. 値の変更に強いテスト設計

#### 禁止事項

- [ ] **マジックナンバーを直接テストに書く**
  ```typescript
  // ❌ NG: 値が変わるとテストが壊れる
  expect(result).toBe(100);
  ```
- [ ] **ハードコードされた値に依存する**
  ```typescript
  // ❌ NG: 日付が変わるとテストが壊れる
  expect(date).toBe("2025-12-06");
  ```
- [ ] **実装の内部値に依存する**
  ```typescript
  // ❌ NG: デフォルト値が変わるとテストが壊れる
  expect(config.maxItems).toBe(10);
  ```

#### 推奨事項

- [ ] **定数化・設定化する**
  ```typescript
  // ✅ OK: 定数として定義
  const MAX_ITEMS = 10;
  expect(result).toBe(MAX_ITEMS);
  ```
- [ ] **相対的な値で検証する**
  ```typescript
  // ✅ OK: 相対的な関係を検証
  expect(result).toBeGreaterThan(0);
  expect(result).toBeLessThanOrEqual(MAX_ITEMS);
  ```
- [ ] **データ駆動テストを使用**
  ```typescript
  // ✅ OK: テストデータを外部化
  const testCases = [
    { input: 1, expected: "one" },
    { input: 2, expected: "two" },
  ];
  testCases.forEach(({ input, expected }) => {
    expect(convert(input)).toBe(expected);
  });
  ```
- [ ] **意味のある値で検証する**
  ```typescript
  // ✅ OK: ビジネスルールに基づく値
  expect(price).toBe(calculatePrice(basePrice, taxRate));
  ```

### 3. テストの安定性（フレーキーテストの回避）

#### 禁止事項

- [ ] **時間に依存するテスト**
  ```typescript
  // ❌ NG: 実行時間に依存
  expect(performance.now()).toBeLessThan(100);
  ```
- [ ] **実行順序に依存するテスト**
  ```typescript
  // ❌ NG: 他のテストの実行結果に依存
  expect(globalState.value).toBe(previousTestResult);
  ```
- [ ] **外部環境に依存するテスト**
  ```typescript
  // ❌ NG: ネットワークやファイルシステムに依存
  expect(fetch("https://example.com")).resolves.toBeDefined();
  ```

#### 推奨事項

- [ ] **時間をモック化する**
  ```typescript
  // ✅ OK: 時間を固定
  jest.useFakeTimers();
  jest.setSystemTime(new Date("2025-12-06"));
  ```
- [ ] **テスト間で状態を共有しない**
  ```typescript
  // ✅ OK: 各テストで独立した状態を準備
  beforeEach(() => {
    resetState();
  });
  ```
- [ ] **外部依存をモック化する**
  ```typescript
  // ✅ OK: 外部APIをモック
  jest.mock("./api");
  ```

### 4. テストの保守性

#### 推奨事項

- [ ] **テストコードも DRY 原則を適用**
  - 共通のセットアップを`beforeEach`に抽出
  - テストデータの生成をヘルパー関数に抽出
- [ ] **テスト名は明確で理解しやすい**
  ```typescript
  // ✅ OK: 何をテストしているか明確
  test("ユーザーが有効なメールアドレスを入力した場合、バリデーションが成功する", () => {
    // ...
  });
  ```
- [ ] **テストデータの準備を簡潔に**
  ```typescript
  // ✅ OK: ファクトリー関数を使用
  const user = createUser({ email: "test@example.com" });
  ```
- [ ] **アサーションは明確に**
  ```typescript
  // ✅ OK: 期待値が明確
  expect(result).toEqual({
    success: true,
    data: expectedData,
  });
  ```

### 5. 実装変更に強いテストの例

#### ❌ NG 例：実装の詳細に依存

```typescript
// 実装の詳細（配列の長さ）を直接テスト
test("配列の長さが10になる", () => {
  const result = processItems(items);
  expect(result.length).toBe(10); // 実装が変わると壊れる
});
```

#### ✅ OK 例：振る舞いをテスト

```typescript
// 振る舞い（最大件数の制限）をテスト
test("最大10件まで処理される", () => {
  const items = Array.from({ length: 20 }, (_, i) => ({ id: i }));
  const result = processItems(items);
  expect(result.length).toBe(MAX_ITEMS); // 定数を使用
  expect(result.every((item) => item.processed)).toBe(true);
});
```

#### ❌ NG 例：値に直接依存

```typescript
// ハードコードされた値に依存
test("価格が1000円になる", () => {
  const price = calculatePrice(100, 10);
  expect(price).toBe(1000); // 税率が変わると壊れる
});
```

#### ✅ OK 例：計算ロジックをテスト

```typescript
// 計算ロジック（価格 × 税率）をテスト
test("価格に税率を掛けた金額が返される", () => {
  const basePrice = 100;
  const taxRate = 0.1;
  const price = calculatePrice(basePrice, taxRate);
  expect(price).toBe(basePrice * (1 + taxRate)); // 計算式を検証
});
```

---

## フロントエンド向けのテストガイドライン

**重要**: E2Eテストやコンポーネントテストでは、**`data-testid`属性を使用して要素を選択すること**を強く推奨します。`data-testid`を使用することで、UIの変更（クラス名、テキスト、構造の変更）に影響されにくい、安定したテストを書くことができます。

### 1. `data-testid`の使用は必須

#### 原則

- [ ] **E2Eテストでは`data-testid`を優先的に使用**
  - `getByRole`や`getByText`は、複数の要素にマッチする可能性がある（strict mode violation）
  - `data-testid`は一意に識別できるため、テストが安定する
- [ ] **コンポーネントテストでも`data-testid`を推奨**
  - 特に、ユーザーインタラクション（クリック、入力等）をテストする場合
  - テストの意図が明確になる
- [ ] **UIの変更に強いテスト設計**
  - クラス名、テキスト、構造が変わってもテストが壊れない
  - 実装の詳細に依存しない

#### `data-testid`を使うべき場面

- [ ] **フォームの入力フィールド**
  - ユーザー名、パスワード、メールアドレス等の入力フィールド
- [ ] **ボタン（特に複数のボタンが存在する場合）**
  - 送信ボタン、キャンセルボタン、削除ボタン等
- [ ] **エラーメッセージ**
  - バリデーションエラー、APIエラー等のメッセージ表示
- [ ] **モーダル、ダイアログ**
  - 確認ダイアログ、エラーダイアログ等
- [ ] **リスト、テーブルの行**
  - 動的に生成される要素で、特定の行を選択する場合
- [ ] **ナビゲーション要素**
  - メニュー項目、リンク等

#### `data-testid`を使わない場面

- [ ] **セマンティックな要素（アクセシビリティが重要）**
  - `getByRole`を使用する方が適切な場合（例：`getByRole("button", { name: "送信" })`）
  - ただし、複数の要素にマッチする場合は`data-testid`を使用
- [ ] **単体テストでの内部実装の検証**
  - コンポーネントの内部実装を直接テストする場合は、`data-testid`は不要

### 2. `data-testid`の命名規則

#### 基本規則

- [ ] **ケバブケース（kebab-case）を使用**
  - 例：`login-username-input`、`login-submit-button`
- [ ] **意味のある名前を付ける**
  - 要素の役割や機能を明確に表現
  - テストの意図が明確になる
- [ ] **一貫性を保つ**
  - 同じ機能を持つ要素は同じ命名規則を使用
  - 例：`{feature}-{element-type}-{purpose}`形式

#### 命名パターン

```typescript
// ✅ OK: 機能-要素タイプ-目的の形式
data-testid="login-username-input"      // ログイン機能のユーザー名入力フィールド
data-testid="login-password-input"       // ログイン機能のパスワード入力フィールド
data-testid="login-submit-button"         // ログイン機能の送信ボタン
data-testid="login-error-message"         // ログイン機能のエラーメッセージ
data-testid="user-list-item-{id}"         // ユーザーリストの項目（動的IDを含む場合）

// ❌ NG: 意味が不明確
data-testid="input1"                     // 何の入力フィールドか不明
data-testid="btn"                        // 何のボタンか不明
data-testid="error"                      // どの機能のエラーか不明
```

### 3. `data-testid`の実装例

#### Reactコンポーネントでの実装

```typescript
// ✅ OK: フォームコンポーネントに`data-testid`を追加
export function LoginForm() {
  return (
    <form onSubmit={handleSubmit}>
      <Input
        type="text"
        placeholder="username"
        data-testid="login-username-input"
        {...field}
      />
      <Input
        type="password"
        placeholder="password"
        data-testid="login-password-input"
        {...field}
      />
      {error && (
        <div
          className="text-sm text-red-500"
          role="alert"
          data-testid="login-error-message"
        >
          {error}
        </div>
      )}
      <Button
        type="submit"
        data-testid="login-submit-button"
        disabled={isLoading}
      >
        {isLoading ? "ログイン中..." : "ログイン"}
      </Button>
    </form>
  );
}
```

#### E2Eテストでの使用

```typescript
// ✅ OK: `data-testid`を使用したE2Eテスト
test("正常系 - ログイン成功", async ({ page }) => {
  // Given: ログイン画面にアクセス
  await page.goto("/login");

  // When: 有効なユーザー名とパスワードを入力
  await page.getByTestId("login-username-input").fill("admin");
  await page.getByTestId("login-password-input").fill("password");

  // When: ログインボタンをクリック
  await page.getByTestId("login-submit-button").click();

  // Then: ログイン成功後のリダイレクトを待つ
  await page.waitForURL("/", { timeout: 10000 });
});

// ❌ NG: `getByRole`や`getByText`を使用（複数の要素にマッチする可能性がある）
test("正常系 - ログイン成功", async ({ page }) => {
  await page.goto("/login");
  await page.getByLabel("ユーザー名").fill("admin");
  await page.getByLabel("パスワード").fill("password");
  // エラー: strict mode violation - 複数のボタンにマッチする可能性がある
  await page.getByRole("button", { name: "ログイン" }).click();
});
```

### 4. `data-testid`とアクセシビリティのバランス

#### 原則

- [ ] **アクセシビリティが重要な場合は`getByRole`を優先**
  - セマンティックな要素（`button`、`link`、`heading`等）は`getByRole`を使用
  - ただし、複数の要素にマッチする場合は`data-testid`を使用
- [ ] **`data-testid`は補助的な役割**
  - アクセシビリティの代替手段ではない
  - テストの安定性を向上させるための補助的な手段

#### 使い分けの例

```typescript
// ✅ OK: アクセシビリティが重要で、一意に識別できる場合
await page.getByRole("button", { name: "送信" }).click();

// ✅ OK: 複数の要素にマッチする可能性がある場合は`data-testid`を使用
await page.getByTestId("login-submit-button").click();

// ✅ OK: セマンティックな要素がない場合（div等）は`data-testid`を使用
await page.getByTestId("error-message").toBeVisible();
```

### 5. `data-testid`のチェックリスト

#### 実装時のチェックリスト

- [ ] **すべてのインタラクティブ要素に`data-testid`を追加**
  - フォームの入力フィールド
  - ボタン（特に複数のボタンが存在する場合）
  - エラーメッセージ
  - モーダル、ダイアログ
- [ ] **命名規則に従っている**
  - ケバブケース（kebab-case）を使用
  - 意味のある名前を付けている
  - 一貫性を保っている
- [ ] **E2Eテストで`getByTestId`を使用**
  - `getByRole`や`getByText`の代わりに`getByTestId`を使用
  - strict mode violationを避ける
- [ ] **テストの安定性を確保**
  - UIの変更（クラス名、テキスト、構造）に影響されない
  - 実装の詳細に依存しない

#### テスト作成時のチェックリスト

- [ ] **E2Eテストで`data-testid`を使用している**
  - フォームの入力フィールド
  - ボタン（特に複数のボタンが存在する場合）
  - エラーメッセージ
- [ ] **strict mode violationを避けている**
  - 複数の要素にマッチする可能性がある場合は`data-testid`を使用
- [ ] **テストの意図が明確**
  - `data-testid`の名前から、何をテストしているかが明確

---

## 観点のチェックリスト

### 2-1. 入力・データまわり

**重要**: 正常系は動いて当たり前です。テストの重点は**異常系・境界値**に置くべきです。

#### 正常系（最小限で OK）

- [ ] よくある値、代表値（1〜2 個程度で十分）
- [ ] 典型的な使用パターン（ハッピーパスの確認程度）

#### 境界値（重点的にテスト）

- [ ] 最小値
- [ ] 最大値
- [ ] 0（ゼロ）
- [ ] マイナス値（該当する場合）
- [ ] 空文字列 / 空配列
- [ ] NULL / undefined（該当する場合）
- [ ] 境界値付近（最小値-1、最大値+1 等）

#### 異常系（網羅的にテスト）

- [ ] 型違い（文字列を数値として扱う等）
- [ ] 桁オーバー（最大値を超える値）
- [ ] 不正フォーマット（日付、メールアドレス等）
- [ ] 禁止文字（特殊文字、制御文字等）
- [ ] すべてのエラーケースをカバー

#### 組み合わせ

- [ ] 「A は OK+B は NG」のようなパターン
- [ ] 重要な組み合わせだけをピックアップ（全部はやらない）
- [ ] 相互依存する値の組み合わせ

#### ロケール/文字種

- [ ] 全角/半角
- [ ] 絵文字
- [ ] 改行、タブ
- [ ] 日付フォーマット（`YYYY-MM-DD` / `/` / 時刻付き など）
- [ ] 多言語文字（日本語、英語、中国語等）

### 2-2. 状態・フロー

#### 状態遷移

- [ ] 許可される遷移（例：`下書き → 承認待ち → 承認済み → 完了`）
- [ ] 許可されない遷移（例：`完了 → 下書き` は不可）
- [ ] 初期状態からの遷移
- [ ] 終了状態への遷移

#### 画面/ステップフロー

- [ ] ハッピーパス（想定通りに進んだ場合）
- [ ] 中断・キャンセル
- [ ] 戻るボタン
- [ ] リロード（F5）
- [ ] 入力途中でログアウト
- [ ] セッション切れ

### 2-3. 時間・並行・順序

#### 時間依存

- [ ] 日付境界（23:59→00:00、月末/年度末）
- [ ] 締め切り直前 / 直後
- [ ] タイムゾーンの違い
- [ ] うるう年、うるう秒

#### 並行実行

- [ ] 同じリソースに対する二重更新
- [ ] 同じボタンの二重クリック・連打
- [ ] 同時アクセス（ロック機構の確認）

#### 順序依存

- [ ] 「先に A を登録してから B」前提が壊れた場合
- [ ] 依存関係のある処理の順序

### 2-4. エラー / 障害系

#### 外部 API

- [ ] タイムアウト
- [ ] 5xx（サーバーエラー）
- [ ] 4xx（クライアントエラー）
- [ ] 想定外のレスポンス形式
- [ ] ネットワークエラー

#### DB

- [ ] 一時的な失敗
- [ ] ユニーク制約違反
- [ ] ロックが取れない
- [ ] 接続エラー
- [ ] トランザクションエラー

#### ネットワーク

- [ ] 接続不可
- [ ] 途中切断
- [ ] 遅延

#### エラーハンドリング

- [ ] **エラーレスポンス形式の検証（必須）**
  - HTTPステータスコードが正しいか
  - レスポンスボディの形式が期待通りか（`{"detail": "..."}`形式など、プロジェクトで定義された形式）
  - エラーメッセージが適切か（ローカライズされているか、ユーザーにとって理解しやすいか）
  - 期待しないフィールドが含まれていないか
- [ ] **422エラー（バリデーションエラー）の詳細形式を検証**
  - `detail`配列の構造が正しいか
  - 各エラー要素に必要なフィールド（`type`, `loc`, `msg`, `input`等）が含まれているか
  - 複数のバリデーションエラーがすべて含まれているか
- [ ] ユーザー向けメッセージの確認
- [ ] ログの内容（どの情報を出す/出さないか）
- [ ] エラーコードの確認
- [ ] リトライ機構の確認

### 2-5. 非機能（ざっくりでも）

#### パフォーマンス

- [ ] 想定最大件数に対するレスポンス時間
- [ ] メモリ使用量
- [ ] CPU 使用率

#### セキュリティ

- [ ] ロール/権限（見える/触れる/触れない）
- [ ] 入力値チェック（XSS、SQLi 等）
- [ ] 認証・認可の確認
- [ ] 機密情報の漏洩防止

#### ログ・監視

- [ ] 成功/失敗のログ
- [ ] トレース ID
- [ ] エラー時の詳細情報
- [ ] 監視アラートの確認

---

## レベル別の意識

### 3-1. 単体テスト（多方向を意識）

**目的**: ドメインロジックのルールを、細かい例でガッチリ固める。

#### 多方向 = いろんな軸で攻める

- [ ] **値のバリエーション**: 境界＋代表＋異常
  - **正常系は最小限**（代表的なケース 1〜2 個程度）
  - **異常系・境界値に重点**（すべてのエラーケース、境界値）
- [ ] **条件分岐の全パス**: if/else, switch のすべての分岐
  - 特にエラーケースの分岐を重点的に
- [ ] **状態変化前後**: Before/After の値の確認

#### ブラックボックス寄りで OK

- [ ] 「入力 → 出力・副作用」が正しいか
- [ ] 内部実装は変わっても落ちないテストを心がける
- [ ] 実装の詳細に依存しないテスト設計
- [ ] **値の変更に強いテスト設計**（マジックナンバーを避ける、定数化、データ駆動テスト）

#### ホワイトボックスは補助

- [ ] カバレッジで抜け漏れ確認
- [ ] ただし「カバレッジ 100%」を目的にしない
- [ ] カバレッジは「抜け漏れ検知ツール」として使用

#### テストファースト

- [ ] 仕様（ルール）を Given-When-Then で書いてからコードを書く
- [ ] **バグが出たら、先にテストを 1 つ追加 → 直す → 回す**
- [ ] テストコード内で BDD 形式コメント（Given-When-Then-And）を記載

### 3-2. 結合 / API テスト

- [ ] **コンポーネント間の契約チェック**
  - 入力スキーマ / 出力スキーマ（型、フィールド名）
  - ステータスコード / エラー形式
- [ ] **エラーレスポンス形式の検証（必須）**
  - すべてのエラーレスポンス（400, 401, 403, 404, 422, 500等）の形式を検証
  - HTTPステータスコード、Content-Typeヘッダー、レスポンスボディの構造を検証
  - エラーメッセージの内容（ローカライズ、理解しやすさ）を検証
  - 422エラーの詳細形式（`detail`配列の構造）を検証
- [ ] **ブラックボックステストを優先**
  - APIの入力と出力のみを検証（内部実装に依存しない）
  - 実装が変わっても同じ振る舞いならテストは通る
- [ ] **代表的なフローだけをカバー**
  - 正常パターン数個＋主要なエラーケース
- [ ] **外部サービスは**
  - スタブ/モック or サンドボックス環境を使う
- [ ] **実装の詳細に依存しない**
  - API の仕様（契約）をテストする
  - 内部実装の変更に影響されない

### 3-3. E2E / 受け入れテスト（BDD の表舞台）

- [ ] **BDD の Feature/Scenario をそのままテストに**
  - ハッピーパス（受け入れ条件をすべて満たす）
  - 代表的なバッドパス（権限不足・入力エラーなど）
- [ ] **数は絞る（重要機能に集中）**
- [ ] **`data-testid`を使用してテストの安定性を確保**
  - UIの変更（クラス名、テキスト、構造）に影響されにくい
  - strict mode violationを避ける
  - 詳細は[フロントエンド向けのテストガイドライン](#フロントエンド向けのテストガイドライン)を参照
- [ ] **UI 変更に弱いので**
  - 重要パスのみ or API ベースのアクセプタンスも混ぜる
  - `data-testid`を使用することで、UI変更の影響を最小化
- [ ] **テストの安定性を確保**
  - 時間依存を避ける
  - 外部環境への依存を最小化
  - `data-testid`を使用して要素を選択

### 3-4. 回帰テスト

- [ ] **バグを 1 つ直したら「必ず 1 つテストを追加」**
  - 再現ケース + 二度と同じバグが起きないように
- [ ] **重大インシデントは**
  - 専用の回帰テストセットに入れて、常に回す
- [ ] **影響範囲が広い変更時は**
  - 関連する既存テストの見直しも実施
- [ ] **実装変更に強いテストを維持**
  - 値の変更で壊れないテスト設計を維持

---

## BDD 前提でのテストの作り方

### 1. まずストーリー/ユースケースを書く

- 「誰が / なぜ / 何をしたいか」を明確にする
- ユーザーストーリー形式（As〜I want〜So that〜）で記述

### 2. 受け入れ条件（AC）を列挙

- これは箇条書きで OK
- 各受け入れ条件が明確で検証可能であることを確認

### 3. AC を Given-When-Then の Scenario/Example に落とす

- 正常系・境界・異常を Examples で表現
- 各シナリオは独立して実行可能であることを確認

### 4. Scenario からテストレベルに割り振る

- **ビジネスルール → 単体テスト**
- **コンポーネント協調 → 結合/API テスト**
- **ユーザー操作全体 → E2E**

### 5. テストコードの実装

- **テストコード内で BDD 形式コメント（Given-When-Then-And）を記載**
  - **Given**: テストの前提条件（初期状態、準備データ等）
  - **When**: テスト対象の動作（実行する操作、関数呼び出し等）
  - **Then**: 期待される結果（アサーション、期待値等）
  - **And**: 追加の前提条件や期待結果（複数の条件がある場合）
  - **記載形式**: コメントとして `// Given: ...`, `// When: ...`, `// Then: ...`, `// And: ...` の形式で記載
- **運用保守に耐えうるテスト設計を意識**
  - 実装の詳細に依存しない
  - 値の変更に強い
  - テストの安定性を確保
- **参照パス確認は必須**: テスト作成時にドキュメントを生成する場合は、**必ずすべての参照パスが正しいか確認すること**
  - **確認タイミング**: ドキュメント作成時、更新時、レビュー時
  - **確認方法**: すべての参照パス（Markdown リンク形式）を確認し、実際のファイルパスと一致しているか検証する
  - **確認項目**:
    - 相対パスの形式が正しいか（`./`、`../` など）
    - ファイル名が正しいか（大文字小文字、拡張子を含む）
    - ディレクトリ構造が正しいか
    - リンク形式が正しいか（Markdown リンク形式: `[テキスト](./パス)`）
  - **禁止事項**:
    - 参照パスを推測する
    - ファイル名を記憶に基づいて記載する
    - ディレクトリ構造を確認せずに参照パスを記載する
    - ファイルが存在しないのに参照パスを記載する
  - **必須事項**: 参照パスを記載する前に、必ず実際のファイルパスを確認する
  - **詳細**: 参照パス確認の詳細なルールは [`AGENTS.md`](./AGENTS.md) の「ドキュメント原則」セクションを参照

---

## テスト作成時の小さな指針

ざっくり、これだけ意識しておくとかなり安定します。

### 基本原則

- [ ] **1 テスト = 1 つの「期待される振る舞い」の確認**
- [ ] **正常系は動いて当たり前：異常系・境界値に重点を置く**
  - 正常系は最小限（代表的なケース 1〜2 個程度）
  - 異常系は網羅的に（すべてのエラーケースをカバー）
  - 境界値も重点的に（最小値、最大値、0、NULL 等）
- [ ] **バリデーション系は網羅的にテスト**
  - すべてのバリデーションルールをテスト
  - 境界値も重点的に
  - エラーメッセージも確認
- [ ] **エラーレスポンス形式の検証は必須**
  - すべてのエラーレスポンス（400, 401, 403, 404, 422, 500等）の形式を検証
  - HTTPステータスコード、Content-Typeヘッダー、レスポンスボディの構造を検証
  - エラーメッセージの内容（ローカライズ、理解しやすさ）を検証
  - 422エラーの詳細形式（`detail`配列の構造）を検証
- [ ] **ブラックボックステストを優先**
  - APIの入力と出力のみを検証（内部実装に依存しない）
  - 実装が変わっても同じ振る舞いならテストは通る
- [ ] **ホワイトボックステストで補完**
  - エラーハンドラーや例外処理の内部実装を検証
  - カバレッジの抜け漏れ確認
- [ ] **E2Eテストでは`data-testid`を使用**
  - UIの変更に影響されにくい、安定したテストを書く
  - strict mode violationを避ける
  - 詳細は[フロントエンド向けのテストガイドライン](#フロントエンド向けのテストガイドライン)を参照
- [ ] **バグを見つけたら、修正前にテストを書く**
- [ ] **カバレッジは「抜け漏れ検知ツール」であって、ゴールではない**
- [ ] **壊れやすい（実装依存が強い）テストはできるだけシナリオ側に寄せ直す**
- [ ] **ロジック的に正しいのに値を変えたら動かなくなるようなテストは絶対に NG**
- [ ] **参照パス確認**: テスト作成時にドキュメントを生成する場合は、すべての参照パスが正しいか確認する（Markdown リンク形式、相対パス、ファイル名、ディレクトリ構造を確認）

### テストコードの品質

- [ ] **テスト名は明確で理解しやすい**
  - 「何をテストしているか」が一目でわかる
  - テストの意図が明確である
- [ ] **テストは独立して実行可能**
  - 他のテストに依存しない
  - 実行順序に依存しない
- [ ] **テストは高速に実行できる**
  - 不要な I/O を避ける
  - モック/スタブを適切に使用
- [ ] **テストは保守しやすい**
  - 重複を避ける（DRY 原則）
  - テストデータの準備を簡潔に
- [ ] **実装の詳細に依存しない**
  - 公開インターフェースを通じてテストする
  - 振る舞い（仕様）を検証する
- [ ] **値の変更に強い**
  - マジックナンバーを避ける
  - 定数化・設定化する
  - データ駆動テストを使用

### テスト実行の原則

- [ ] **テストファースト**: 実装前にテストを書く
- [ ] **プロダクションレディ**: テストは本番環境と同じ条件で実行
- [ ] **環境の一貫性**: 開発環境と同じ環境でテストを実行することで、環境の違いによる問題を防ぐ
- [ ] **テストの安定性**: フレーキーテスト（不安定なテスト）を避ける

---

## 参考資料

### テスト技法

- **回帰テスト**: 既存機能が壊れていないことを確認
- **エッジケース**: 境界値や特殊な条件での動作確認
- **ブラックボックス**: 内部実装を知らずに入力と出力を確認
- **ホワイトボックス**: 内部実装を理解した上でテスト
- **境界値**: 最小値、最大値、0、NULL 等の境界での動作確認
- **BDD**: 振る舞い駆動開発、Given-When-Then 形式
- **テストファースト**: 実装前にテストを書く
- **単体テスト多方向**: 様々な観点からテストを書く

### 関連ドキュメント

- [`AGENTS_AI_PLAYBOOK.md`](./AGENTS_AI_PLAYBOOK.md): AI エージェント向けの実行ルール（このガイドラインは実装フェーズから参照されます）
- [`AGENTS.md`](./AGENTS.md): 開発規約の全体像
- [`AGENTS_REVIEW_RULE.md`](./AGENTS_REVIEW_RULE.md): レビュー時の徹底的な品質調査ルール

---

**最終更新**: 2026 年 1 月 11 日（エラーレスポンス形式の検証、ブラックボックステスト、ホワイトボックステスト、フロントエンド向けのテストガイドライン（`data-testid`の使用）の要件を追加）
